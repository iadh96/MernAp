/**
 * The `readline` module provides an interface for reading data from a `Readable` stream (such as `process.stdin`) one line at a time.
 *
 * To use the promise-based APIs:
 *
 * ```js
 * import * as readline from 'node:readline/promises';
 * ```
 *
 * To use the callback and sync APIs:
 *
 * ```js
 * import * as readline from 'node:readline';
 * ```
 *
 * The following simple example illustrates the basic use of the `readline` module.
 *
 * ```js
 * import * as readline from 'node:readline/promises';
 * import { stdin as input, stdout as output } from 'process';
 *
 * const rl = readline.createInterface({ input, output });
 *
 * const answer = await rl.question('What do you think of Node.js? ');
 *
 * console.log(`Thank you for your valuable feedback: ${answer}`);
 *
 * rl.close();
 * ```
 *
 * Once this code is invoked, the Node.js application will not terminate until the`readline.Interface` is closed because the interface waits for data to be
 * received on the `input` stream.
 * @see [source](https://github.com/nodejs/node/blob/v17.0.0/lib/readline.js)
 */
declare module 'readline' {
    import { Abortable, EventEmitter } from 'node:events';
    interface Key {
        sequence?: string | undefined;
        name?: string | undefined;
        ctrl?: boolean | undefined;
        meta?: boolean | undefined;
        shift?: boolean | undefined;
    }
    /**
     * Instances of the `readline.Interface` class are constructed using the`readline.createInterface()` method. Every instance is associated with a
     * single `input` `Readable` stream and a single `output` `Writable` stream.
     * The `output` stream is used to print prompts for user input that arrives on,
     * and is read from, the `input` stream.
     * @since v0.1.104
     */
    class Interface extends EventEmitter {
        readonly terminal: boolean;
        /**
         * The current input data being processed by node.
         *
         * This can be used when collecting input from a TTY stream to retrieve the
         * current value that has been processed thus far, prior to the `line` event
         * being emitted. Once the `line` event has been emitted, this property will
         * be an empty string.
         *
         * Be aware that modifying the value during the instance runtime may have
         * unintended consequences if `rl.cursor` is not also controlled.
         *
         * **If not using a TTY stream for input, use the `'line'` event.**
         *
         * One possible use case would be as follows:
         *
         * ```js
         * const values = ['lorem ipsum', 'dolor sit amet'];
         * const rl = readline.createInterface(process.stdin);
         * const showResults = debounce(() => {
         *   console.log(
         *     '\n',
         *     values.filter((val) => val.startsWith(rl.line)).join(' ')
         *   );
         * }, 300);
         * process.stdin.on('keypress', (c, k) => {
         *   showResults();
         * });
         * ```
         * @since v0.1.98
         */
        readonly line: string;
        /**
         * The cursor position relative to `rl.line`.
         *
         * This will track where the current cursor lands in the input string, when
         * reading input from a TTY stream. The position of cursor determines the
         * portion of the input string that will be modified as input is processed,
         * as well as the column where the terminal caret will be rendered.
         * @since v0.1.98
         */
        readonly cursor: number;
        /**
         * NOTE: According to the documentation:
         *
         * > Instances of the `readline.Interface` class are constructed using the
         * > `readline.createInterface()` method.
         *
         * @see https://nodejs.org/dist/latest-v10.x/docs/api/readline.html#readline_class_interface
         */
        protected constructor(input: NodeJS.ReadableStream, output?: NodeJS.WritableStream, completer?: Completer | AsyncCompleter, terminal?: boolean);
        /**
         * NOTE: According to the documentation:
         *
         * > Instances of the `readline.Interface` class are constructed using the
         * > `readline.createInterface()` method.
         *
         * @see https://nodejs.org/dist/latest-v10.x/docs/api/readline.html#readline_class_interface
         */
        protected constructor(options: ReadLineOptions);
        /**
         * The `rl.getPrompt()` method returns the current prompt used by `rl.prompt()`.
         * @since v15.3.0
         * @return the current prompt string
         */
        getPrompt(): string;
        /**
         * The `rl.setPrompt()` method sets the prompt that will be written to `output`whenever `rl.prompt()` is called.
         * @since v0.1.98
         */
        setPrompt(prompt: string): void;
        /**
         * The `rl.prompt()` method writes the `readline.Interface` instances configured`prompt` to a new line in `output` in order to provide a user with a new
         * location at which to provide input.
         *
         * When called, `rl.prompt()` will resume the `input` stream if it has been
         * paused.
         *
         * If the `readline.Interface` was created with `output` set to `null` or`undefined` the prompt is not written.
         * @since v0.1.98
         * @param preserveCursor If `true`, prevents the cursor placement from being reset to `0`.
         */
        prompt(preserveCursor?: boolean): void;
        /**
         * The `rl.question()` method displays the `query` by writing it to the `output`,
         * waits for user input to be provided on `input`, then invokes the `callback`function passing the provided input as the first argument.
         *
         * When called, `rl.question()` will resume the `input` stream if it has been
         * paused.
         *
         * If the `readline.Interface` was created with `output` set to `null` or`undefined` the `query` is not written.
         *
         * The `callback` function passed to `rl.question()` does not follow the typical
         * pattern of accepting an `Error` object or `null` as the first argument.
         * The `callback` is called with the provided answer as the only argument.
         *
         * Example usage:
         *
         * ```js
         * rl.question('What is your favorite food? ', (answer) => {
         *   console.log(`Oh, so your favorite food is ${answer}`);
         * });
         * ```
         *
         * Using an `AbortController` to cancel a question.
         *
         * ```js
         * const ac = new AbortController();
         * const signal = ac.signal;
         *
         * rl.question('What is your favorite food? ', { signal }, (answer) => {
         *   console.log(`Oh, so your favorite food is ${answer}`);
         * });
         *
         * signal.addEventListener('abort', () => {
         *   console.log('The food question timed out');
         * }, { once: true });
         *
         * setTimeout(() => ac.abort(), 10000);
         * ```
         *
         * If this method is invoked as it's util.promisify()ed version, it returns a
         * Promise that fulfills with the answer. If the question is canceled using
         * an `AbortController` it will reject with an `AbortError`.
         *
         * ```js
         * const util = require('util');
         * const question = util.promisify(rl.question).bind(rl);
         *
         * async function questionExample() {
         *   try {
         *     const answer = await question('What is you favorite food? ');
         *     console.log(`Oh, so your favorite food is ${answer}`);
         *   } catch (err) {
         *     console.error('Question rejected', err);
         *   }
         * }
         * questionExample();
         * ```
         * @since v0.3.3
         * @param query A statement or query to write to `output`, prepended to the prompt.
         * @param callback A callback function that is invoked with the user's input in response to the `query`.
         */
        question(query: string, callback: (answer: string) => void): void;
        question(query: string, options: Abortable, callback: (answer: string) => void): void;
        /**
         * The `rl.pause()` method pauses the `input` stream, allow